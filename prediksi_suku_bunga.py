# -*- coding: utf-8 -*-
"""prediksi_suku_bunga.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WOaWIIKXTxPuUXACD1SXkO479f4SCAUO

## IMPORT LIBRARY
"""

import pandas as pd
import numpy as np
import seaborn as sns
from scipy import stats
import matplotlib.pyplot as plt
import hvplot.pandas

from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.preprocessing import MinMaxScaler

from sklearn.metrics import ConfusionMatrixDisplay, RocCurveDisplay, confusion_matrix, classification_report, accuracy_score

from xgboost import XGBClassifier
from sklearn.ensemble import RandomForestClassifier

import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Input, Dense, BatchNormalization, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import AUC

"""## DATA LOADING"""

# Load dataset
df = pd.read_csv('pinjaman_dataset.csv')

# Menampilkan 5 baris pertama dari dataset
df.head()

# Menampilkan informasi tentang dataset
df.info()

# Ubah nama setiap kolom
df.rename(columns={
    'loan_amnt': 'jumlah_pinjaman',
    'term': 'jangka_waktu',
    'int_rate': 'suku_bunga',
    'installment': 'angsuran',
    'grade': 'kelas',
    'sub_grade': 'sub_kelas',
    'emp_title': 'jabatan_pekerjaan',
    'emp_length': 'lama_bekerja',
    'home_ownership': 'kepemilikan_rumah',
    'annual_inc': 'pendapatan_tahunan',
    'verification_status': 'status_verifikasi',
    'issue_d': 'tanggal_penerbitan',
    'loan_status': 'status_pinjaman',
    'purpose': 'tujuan_pinjaman',
    'title': 'judul_pinjaman',
    'dti': 'rasio_hutang_pendapatan',
    'earliest_cr_line': 'garis_kredit_terawal',
    'open_acc': 'akun_terbuka',
    'pub_rec': 'catatan_publik',
    'revol_bal': 'saldo_revolving',
    'revol_util': 'utilisasi_revolving',
    'total_acc': 'total_akun',
    'initial_list_status': 'status_awal_pencatatan',
    'application_type': 'jenis_aplikasi',
    'mort_acc': 'akun_hipotek',
    'pub_rec_bankruptcies': 'kebangkrutan_publik',
    'address': 'alamat'
}, inplace=True)

# Melihat jumlah baris dan kolom
print("Jumlah baris dan kolom:", df.shape)

# Menampilkan statistik deskriptif dari dataset
df.describe()

# Menampilkan jumlah nilai yang hilang dalam setiap kolom
df.isnull().sum()

"""## EDA"""

df.head()

df['status_pinjaman'].value_counts().hvplot.bar(
    title="Jumlah Status Pinjaman", xlabel='Status Pinjaman', ylabel='Jumlah',
    width=500, height=350
)

"""Sebagian besar peminjam di dataset berhasil melunasi pinjamannya.

Hanya sebagian kecil yang mengalami gagal bayar (Charged Off).

Hal ini menunjukkan bahwa secara umum, portofolio pinjaman ini memiliki tingkat kelunasan yang cukup baik.
"""

numeric_df = df.select_dtypes(include=[np.number])
sns.heatmap(numeric_df.corr(), annot=True, cmap='viridis')

"""Ditemukan bahwa korelasi paling kuat dalam dataset terdapat antara variabel jumlah pinjaman (loan_amnt) dan angsuran bulanan (installment). Hal ini logis karena semakin besar jumlah pinjaman, maka besarnya angsuran juga cenderung meningkat. Korelasi tinggi ini mengindikasikan hubungan linier yang kuat dan perlu diperhatikan dalam pemodelan suku bunga.

##### jumlah_pinjaman & angsuran
"""

# Visualisasi plot untuk melihat hubungan antara angsuran dan status pinjaman
plt.figure(figsize=(10, 6))
sns.boxplot(x='status_pinjaman', y='angsuran', data=df)
plt.title('Hubungan antara Angsuran dan Status Pinjaman')

# Visualisasi plot untuk melihat hubungan antara jumlah pinjaman dan status pinjaman
plt.figure(figsize=(10, 6))
sns.boxplot(x='status_pinjaman', y='jumlah_pinjaman', data=df)
plt.title('Hubungan antara Jumlah Pinjaman dan Status Pinjaman')
plt.show()

"""Terlihat hubungan linier positif yang sangat kuat antara jumlah pinjaman dan besar angsuran. Artinya, semakin besar pinjaman yang diberikan, maka angsuran per bulan cenderung meningkat. Ini konsisten dengan logika finansial bahwa pinjaman besar memerlukan cicilan yang lebih besar.

Hubungan ini mengindikasikan bahwa salah satu dapat digunakan sebagai proxy untuk yang lain dalam pemodelan, tetapi penting untuk mempertimbangkan kontribusi unik masing-masing terhadap suku bunga.
"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan angsuran
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='angsuran', hue='status_pinjaman', multiple='stack', bins=30)
plt.title('Distribusi Angsuran berdasarkan Status Pinjaman')
plt.show()

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan jumlah pinjaman
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='jumlah_pinjaman', hue='status_pinjaman', multiple='stack', bins=30)
plt.title('Distribusi Jumlah Pinjaman berdasarkan Status Pinjaman')
plt.show()

df.groupby(by='status_pinjaman')['jumlah_pinjaman'].describe()

"""- angsuran: Pembayaran bulanan yang harus dibayarkan oleh peminjam jika pinjaman telah disetujui.
- jumlah_pinjaman: Jumlah pinjaman yang diajukan oleh peminjam. Jika suatu saat departemen kredit mengurangi jumlah pinjaman, maka hal tersebut akan tercermin dalam nilai ini.

##### jangka waktu, kepemilikan_rumah, status_verifikasi & tujuan_pinjaman
"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan kepemilikan rumah
plt.figure(figsize=(10, 6))
sns.countplot(x='kepemilikan_rumah', data=df, hue='status_pinjaman')
plt.title('Jumlah Status Pinjaman berdasarkan Kepemilikan Rumah')
plt.show()

"""Variabel-variabel kategorikal ini menunjukkan pola distribusi yang berbeda-beda terhadap tingkat suku bunga atau jumlah pinjaman.

"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan jangka waktu
plt.figure(figsize=(10, 6))
sns.countplot(x='jangka_waktu', data=df, hue='status_pinjaman')
plt.title('Jumlah Status Pinjaman berdasarkan Jangka Waktu')
plt.show()

"""
jangka waktu pinjaman yang lebih panjang sering kali diikuti oleh suku bunga yang lebih tinggi, menunjukkan adanya risiko tambahan yang diperhitungkan oleh pemberi pinjaman.
"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan status verifikasi
plt.figure(figsize=(10, 6))
sns.countplot(x='status_verifikasi', data=df, hue='status_pinjaman')
plt.title('Jumlah Status Pinjaman berdasarkan Status Verifikasi')
plt.show()

"""
Status verifikasi juga tampaknya berperan dalam pengaruh terhadap penilaian risiko."""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan tujuan pinjaman
plt.figure(figsize=(10, 6))
sns.countplot(x='tujuan_pinjaman', data=df, hue='status_pinjaman')
plt.title('Jumlah Status Pinjaman berdasarkan Tujuan Pinjaman')
plt.show()

"""- jangka waktu: Jumlah pembayaran pinjaman. Nilai dalam bulan dan dapat berupa 36 atau 60.
- kepemilikan_rumah: Status kepemilikan rumah yang diberikan oleh peminjam saat pendaftaran atau diperoleh dari laporan kredit. Nilai yang tersedia adalah: SEWA, MILIK SENDIRI, HIPOTEK, LAINNYA
- status_verifikasi: Menunjukkan apakah pendapatan diverifikasi oleh LC, tidak diverifikasi, atau jika sumber pendapatan diverifikasi
- tujuan_pinjaman: Kategori yang disediakan oleh peminjam untuk permintaan pinjaman.

##### suku_bunga & pendapatan_tahunan
"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan pendapatan tahunan
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='pendapatan_tahunan', hue='status_pinjaman', multiple='stack', bins=30)
plt.title('Distribusi Pendapatan Tahunan berdasarkan Status Pinjaman')
plt.show()

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan suku bunga
plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='suku_bunga', hue='status_pinjaman', multiple='stack', bins=30)
plt.title('Distribusi Suku Bunga berdasarkan Status Pinjaman')
plt.show()

"""- suku_bunga : Suku bunga pinjaman
- pendapatan_tahunan : Pendapatan tahunan yang dilaporkan sendiri oleh peminjam saat pendaftaran

##### jabatan_pekerjaan & lama_bekerja
"""

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan jabatan pekerjaan
# Ambil 10 jabatan paling umum
top_jobs = df['jabatan_pekerjaan'].value_counts().nlargest(10).index

# Filter data hanya untuk 10 jabatan tersebut
filtered_df = df[df['jabatan_pekerjaan'].isin(top_jobs)]

# Plot dengan countplot
plt.figure(figsize=(12, 6))
sns.countplot(data=filtered_df, x='jabatan_pekerjaan', hue='status_pinjaman', order=top_jobs)
plt.title('Distribusi Status Pinjaman berdasarkan 10 Jabatan Pekerjaan Teratas')
plt.xlabel('Jabatan Pekerjaan')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Visualisasi plot untuk melihat jumlah status pinjaman berdasarkan lama bekerja
# Buat urutan kategorikal untuk lama bekerja
lama_bekerja_order = ['< 1 year', '1 year', '2 years', '3 years', '4 years',
                      '5 years', '6 years', '7 years', '8 years', '9 years',
                      '10+ years', 'n/a']

plt.figure(figsize=(12, 6))
sns.countplot(data=filtered_df, x='lama_bekerja', hue='status_pinjaman')
plt.title('Distribusi Lama Bekerja berdasarkan Status Pinjaman')
plt.xlabel('Lama Bekerja')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Keduanya menunjukkan keragaman besar antar kategori, dan berpotensi menunjukkan kestabilan atau risiko peminjam.

Semakin lama seseorang bekerja, secara umum diasumsikan memiliki stabilitas keuangan yang lebih baik, sehingga bisa berdampak pada penetapan bunga pinjaman yang lebih rendah.

- jabatan_pekerjaan : Jabatan yang diberikan oleh Peminjam saat mengajukan pinjaman.
- lama_bekerja : Lama bekerja dalam tahun. Nilai yang dapat dimasukkan adalah antara 0 dan 10 dimana 0 berarti kurang dari satu tahun dan 10 berarti sepuluh tahun atau lebih.

#### Konklusi
Hubungan antar variabel yang ditemukan ini memperlihatkan bahwa suku bunga pinjaman dipengaruhi oleh berbagai faktor â€” baik numerik maupun kategorikal. Tidak ada satu faktor tunggal yang secara dominan menentukan bunga, melainkan kombinasi dari jumlah pinjaman, durasi pinjaman, profil pekerjaan, dan karakteristik peminjam lainnya.

## DATA PREPROCESSING

- Hapus atau isi data yang hilang.
- Menghapus fitur yang tidak perlu atau berulang.
"""

df

# Melihat persentase missing values
for column in df.columns:
    if df[column].isna().sum() != 0:
        missing = df[column].isna().sum()
        portion = (missing / df.shape[0]) * 100
        print(f"'{column}': number of missing values '{missing}' ==> '{portion:.2f}%'")

"""Mari kita cek permasalahan missing values di atas

##### jabatan_pekerjaan
"""

df.jabatan_pekerjaan.nunique()

"""Terdapat banyak sekali jenis jabatan pekerjaan, jadi kita hapus kolom tersebut"""

df.drop('jabatan_pekerjaan', axis=1, inplace=True)

"""##### lama_bekerja"""

df.lama_bekerja.unique()

for year in df.lama_bekerja.unique():
    print(f"{year} years in this position:")
    print(f"{df[df.lama_bekerja == year].status_pinjaman.value_counts(normalize=True)}")
    print('==========================================')

"""Status pinjaman sangat mirip di semua waktu lama bekerja, jadi bisa kita hapus kolom ini.

"""

df.drop('lama_bekerja', axis=1, inplace=True)

"""##### judul_pinjaman"""

df.judul_pinjaman.value_counts().head()

df.tujuan_pinjaman.value_counts().head()

"""Berdasarkan hasil di atas, kolom judul_pinjaman hanya merupakan bagian dari kolom tujuan_pinjaman, jadi tidak diperlukan"""

df.drop('judul_pinjaman', axis=1, inplace=True)

"""##### akun_hipotek"""

df.akun_hipotek.value_counts()

df.akun_hipotek.isna().sum()

numeric_df.corr()['akun_hipotek'].drop('akun_hipotek').sort_values().hvplot.barh()

total_akun_avg = numeric_df.groupby(by='total_akun').mean().akun_hipotek

def fill_akun_hipotek(total_akun, akun_hipotek):
    if np.isnan(akun_hipotek):
        return total_akun_avg[total_akun].round()
    else:
        return akun_hipotek

df['akun_hipotek'] = df.apply(lambda x: fill_akun_hipotek(x['total_akun'], x['akun_hipotek']), axis=1)

"""##### utilisasi_revolving & kebangkrutan_publik

kedua kolom ini memiliki jumlah kurang dari 0.5 % dari total data, jadi kita dapat menghilangkan kolom ini
"""

# Menghapus kolom yang tidak diperlukan
df.drop(['utilisasi_revolving', 'kebangkrutan_publik'], axis=1, inplace=True)

df.shape

"""#### Variabel Kategori"""

# Menampilkan kolom bertipe object
print([column for column in df.columns if df[column].dtype == object])

"""##### jangka_waktu"""

df.jangka_waktu.unique()

jangka_waktu_nilai = {' 36 months': 36, ' 60 months': 60}
df['jangka_waktu'] = df.jangka_waktu.map(jangka_waktu_nilai)

"""##### kelas & sub_kelas

kelas merupakan fitur bagian dari sub_kelas, jadi kita dapat hapus
"""

df.drop('kelas', axis=1, inplace=True)

dummies = ['sub_kelas', 'kepemilikan_rumah', 'status_verifikasi', 'tujuan_pinjaman', 'status_awal_pencatatan', 'jenis_aplikasi']
df = pd.get_dummies(df, columns=dummies, drop_first=True)

"""##### alamat

menampilkan fitur merekayasa kolom kode pos dari alamat dalam kumpulan data
"""

df.alamat.head()

df['zip_code'] = df.alamat.apply(lambda x: x[-5:])
df.zip_code.value_counts()

df = pd.get_dummies(df, columns=['zip_code'], drop_first=True)
df.drop('alamat', axis=1, inplace=True)

"""##### tanggal_penerbitan

Data dapat bocor, kita tidak akan tahu sebelumnya apakah pinjaman akan diberikan atau tidak ketika menggunakan model kita, jadi secara teori kita tidak akan memiliki issue_date, hilangkan fitur ini.
"""

df.drop('tanggal_penerbitan', axis=1, inplace=True)

"""##### garis_kredit_terawal"""

df['garis_kredit_terawal'] = pd.to_datetime(df['garis_kredit_terawal'], format='%b-%Y')
df['garis_kredit_terawal'] = df['garis_kredit_terawal'].dt.year
df.garis_kredit_terawal.nunique()

df.garis_kredit_terawal.value_counts()

"""## MODELS & EVALUATE"""

w_p = df.status_pinjaman.value_counts()[0] / df.shape[0]
w_n = df.status_pinjaman.value_counts()[1] / df.shape[0]

print(f"Weight of positive values {w_p}")
print(f"Weight of negative values {w_n}")

train, test = train_test_split(df, test_size=0.2, random_state=42)

print(train.shape)
print(test.shape)

print(train[train['rasio_hutang_pendapatan'] <= 50].shape)
print(train.shape)

X_train, y_train = train.drop('status_pinjaman', axis=1), train.status_pinjaman
X_test, y_test = test.drop('status_pinjaman', axis=1), test.status_pinjaman

X_train.dtypes

scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

def print_score(true, pred, train=True):
    if train:
        clf_report = pd.DataFrame(classification_report(true, pred, output_dict=True))
        print("Train Result:\n================================================")
        print(f"Accuracy Score: {accuracy_score(true, pred) * 100:.2f}%")
        print("_______________________________________________")
        print(f"CLASSIFICATION REPORT:\n{clf_report}")
        print("_______________________________________________")
        print(f"Confusion Matrix: \n {confusion_matrix(true, pred)}\n")

    elif train==False:
        clf_report = pd.DataFrame(classification_report(true, pred, output_dict=True))
        print("Test Result:\n================================================")
        print(f"Accuracy Score: {accuracy_score(true, pred) * 100:.2f}%")
        print("_______________________________________________")
        print(f"CLASSIFICATION REPORT:\n{clf_report}")
        print("_______________________________________________")
        print(f"Confusion Matrix: \n {confusion_matrix(true, pred)}\n")

from sklearn.preprocessing import LabelEncoder

X_train = np.array(X_train).astype(np.float32)
X_test = np.array(X_test).astype(np.float32)

le = LabelEncoder()
y_train = le.fit_transform(y_train)
y_test = le.transform(y_test)

y_train = y_train.astype(np.float32)
y_test = y_test.astype(np.float32)

def evaluate_nn(true, pred, train=True):
    clf_report = pd.DataFrame(classification_report(true, pred, output_dict=True))

    phase = "Train" if train else "Test"
    print(f"{phase} Result:\n{'=' * 48}")
    print(f"Accuracy Score: {accuracy_score(true, pred) * 100:.2f}%")
    print("_" * 47)
    print(f"CLASSIFICATION REPORT:\n{clf_report}")
    print("_" * 47)
    print(f"Confusion Matrix: \n{confusion_matrix(true, pred)}\n")

def plot_learning_evolution(r):
    plt.figure(figsize=(12, 6))

    # Plot Loss
    plt.subplot(1, 2, 1)
    plt.plot(r.history['loss'], label='Loss')
    plt.plot(r.history['val_loss'], label='Val Loss')
    plt.title('Loss Evolution During Training')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()

    # Plot AUC
    plt.subplot(1, 2, 2)
    plt.plot(r.history['AUC'], label='AUC')
    plt.plot(r.history['val_AUC'], label='Val AUC')
    plt.title('AUC Score Evolution During Training')
    plt.xlabel('Epoch')
    plt.ylabel('AUC')
    plt.legend()

    plt.tight_layout()
    plt.show()

def nn_model(num_columns, num_labels, hidden_units, dropout_rates, learning_rate):
    inp = Input(shape=(num_columns,))
    x = BatchNormalization()(inp)
    x = Dropout(dropout_rates[0])(x)

    for i in range(len(hidden_units)):
        x = Dense(hidden_units[i], activation='relu')(x)
        x = BatchNormalization()(x)
        x = Dropout(dropout_rates[i + 1])(x)

    x = Dense(num_labels, activation='sigmoid')(x)
    model = Model(inputs=inp, outputs=x)
    model.compile(optimizer=Adam(learning_rate), loss='binary_crossentropy', metrics=[AUC(name='AUC')])

    return model

num_columns = X_train.shape[1]
num_labels = 1
hidden_units = [150, 150, 150]
dropout_rates = [0.1, 0, 0.1, 0]
learning_rate = 1e-3


model = nn_model(
    num_columns=num_columns,
    num_labels=num_labels,
    hidden_units=hidden_units,
    dropout_rates=dropout_rates,
    learning_rate=learning_rate
)
r = model.fit(
    X_train, y_train,
    validation_data=(X_test, y_test),
    epochs=20,
    batch_size=32
)

plot_learning_evolution(r)

y_train_pred = model.predict(X_train)
evaluate_nn(y_train, y_train_pred.round(), train=True)

y_test_pred = model.predict(X_test)
evaluate_nn(y_test, y_test_pred.round(), train=False)

from sklearn.metrics import roc_auc_score

scores_dict = {
    'ANNs': {
        'Train': roc_auc_score(y_train, model.predict(X_train)),
        'Test': roc_auc_score(y_test, model.predict(X_test)),
    },
}

"""### XGBoost"""

xgb = XGBClassifier(use_label_encoder=False)

xgb.fit(X_train, y_train)

y_train_pred = xgb.predict(X_train)
y_test_pred = xgb.predict(X_test)

print_score(y_train, y_train_pred, train=True)
print_score(y_test, y_test_pred, train=False)

disp = ConfusionMatrixDisplay.from_estimator(
    xgb, X_test, y_test,
    cmap='Blues', values_format='d',
    display_labels=['Default', 'Fully-Paid']
)

disp = RocCurveDisplay.from_estimator(xgb, X_test, y_test)

scores_dict['XGBoost'] = {
        'Train': roc_auc_score(y_train, xgb.predict(X_train)),
        'Test': roc_auc_score(y_test, xgb.predict(X_test)),
    }

"""### Random Forest"""

rf = RandomForestClassifier(n_estimators=100)

rf.fit(X_train, y_train)

y_train_pred = rf.predict(X_train)
y_test_pred = rf.predict(X_test)

print_score(y_train, y_train_pred, train=True)
print_score(y_test, y_test_pred, train=False)

disp = ConfusionMatrixDisplay.from_estimator(rf, X_test, y_test,
                             cmap='Blues', values_format='d',
                             display_labels=['Default', 'Fully-Paid'])

disp = RocCurveDisplay.from_estimator(xgb, X_test, y_test)
RocCurveDisplay.from_estimator(rf, X_test, y_test, ax=disp.ax_)

scores_dict['Random Forest'] = {
        'Train': roc_auc_score(y_train, rf.predict(X_train)),
        'Test': roc_auc_score(y_test, rf.predict(X_test)),
    }

ml_compare = {
    'Random Forest': rf,
    'XGBoost': xgb,
    'ANNs': model
}

for model in ml_compare:
    print(f"{model.upper():{30}} roc_auc_score: {roc_auc_score(y_test, ml_compare[model].predict(X_test)):.3f}")

scores_df = pd.DataFrame(scores_dict)
scores_df.hvplot.barh(
    width=500, height=400,
    title="ROC Scores of ML Models", xlabel="ROC Scores",
    alpha=0.4, legend='top'
)